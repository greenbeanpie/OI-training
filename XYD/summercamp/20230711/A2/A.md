# Problem A 奇怪的矩阵

## 1.1题目描述

小Y手中有一个 $n \times 10^{18}$的矩阵，虽然说这个知阵实在是太大了，但是也并非毫无规律可循。小Y将给出这个矩阵第一列的 $n$ 个元素，用 $a_i$ 表示第 $i$ 行第一列的元素值。对
于其他的位置，第 $i$ 行第 $j$ 列的元素值为 $a_i+j-1$ 。现在小Y需要知道一些这个矩阵的信息，他会向你提问，在矩阵第 $l$ 列到第 $r$ 列的所有元素中，包含几个不同的值?

## 1.2输人描述

第一行包含一个正整数$n(n \leq 10^5)$，表示矩形的行数

第二行包含 $n$ 个正整数，表示矩阵第一列的元素值，其中 $a_i \leq 10^{18}$ 第三行包含一个正整数 $q(q \leq 10^5)$，表示询问的次数。

随后q行，每行包含两个正整数$l,r(1<l<r \leq 10^{18})$，表示询问的区间。

## 1.3输出描述

输出一行， $q$ 个整数，表示每次询问的答案。

## 1.4样例展示

### 样例输入1

```
6
3 1 4 1 5 9
3
7 7
0 2
8 17
```

### 样例输出1

```
5 10 18
```

## 题解

方向性思考：我们可以看到l和r的数据规模到达了 $10^{18}$ ，可以知道时间复杂度和l、r的大小没有，而 $n$ 的数据规模在 $10^5$ 范围内，考虑时间复杂度为 $O(nlogn)$ 或 $O(n)$

我们假设这一些数在序列是递增的。进一步思考，我们发现因为随着列数的递增，序列中的每一个数也随列数递增的。如果 $a_{i+1}-a_i < r-l$，那么我们显然可以知道 $a_i$ 在增加的过程中已经将 $a_{i+1}$ 和 $a_i$ 之间的差补满，此时在 $a_{i+1}$ 和 $a_i$ 之间多出了 $r-l$ 个数。如果无法补满两者之间的差，那么我们也可以知道在这两者之间多出了 $a_{i+1}-a_i$ 个数。根据这个结论即可得出答案。

但是观察数据我们还发现一个问题。我们发现 $q \leq 10^5$，如果每次暴力判断的话时间复杂度 $O(n^2)$ ，显然会超时，那么怎么办呢？此时我们显然可以进行预处理。我们现在已经知道了答案和 $r-l$ 与 $a_{i+1}-a_i(0 < i \leq n)$ 有关，所以我们可以预处理对于不同的r-l的时候答案是多少。此时时间复杂度为 $O(n)+O(n)$ ，可以通过。处理方法见标程。

## 标程

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);

  int n;
  cin >> n;
  vector<long long> a(n);
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
  }
  sort(a.begin(), a.end());
  
  vector<long long> b(n), s(n);
  for (int i = 1; i < n; ++i) {
    b[i] = a[i] - a[i - 1];
  }
  sort(b.begin(), b.end());
  for (int i = 1; i < n; ++i) {
    s[i] = s[i - 1] + b[i];
  }

  int nq;
  cin >> nq;
  for (long long l, r; nq--; ) {
    cin >> l >> r;
    long long d = r - l + 1;
    int p = upper_bound(b.begin(), b.end(), d) - b.begin() - 1;
    long long ans = s[p] + d * (n - p);
    cout << ans << " ";
  }
  cout << endl;
  
  return 0;
}
```
