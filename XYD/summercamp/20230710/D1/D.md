# 快速排序

## 题目背景

小武最近学习了快速排序，写出了下述的代码

```cpp
void Qsort(int a[], int low, int high)
{
	if (low >= high)
		return;
	int first = low;
	int last = high;
	int key_index = (rand() % (high - low + 1)) + low;
	swap(a[first], a[key_index]);
	int key = a[first];
	while (first < last)
	{
		while (first < last && a[last] >= key)
			--last;
		a[first] = a[last];
		while (first < last && a[first] <= key)
			++first;
		a[last] = a[first];
	}
	a[first] = key;
	Qsort(a, low, first - 1);
	Qsort(a, first + 1, high);
}
```

## 题目描述

这里开始 $low=0$ ， $high=N$ ，数组 $a$ 为 $1$ 到 $N$ 的一个排列

我们采用随机优化的快速排序是很难碰到最坏情况的，但是小林偷偷修改了运行环境，控制了随机数的生成，使得随机数依次为 $a_1,a_2,a_3,...,a_k,a_1,...$ ，即随机数结果依次为 $a_1$ 到 $a_k$ ，然后不断循环。但是还有一个问题，什么样的排列在这样的随机数下效果最差呢，小林认为效果最差即递归的深度最深，但小林不知道怎么找到这个排列，只好交给你

## 输入格式

第一行两个整数 $N$ 和 $k$

接下来 $k$ 行，每行一个数字，表示 $a_1$ 到 $a_k$

## 输出格式

$N$ 行整数，为 $$ 到 $1N$ 的一个排列，若有多个排列满足条件，输出其中字典序最小的那个排列

## 样例 #1

### 样例输入 #1

```
3 1
0
```

### 样例输出 #1

```
1
2
3
```

## 样例 #2

### 样例输入 #2

```
4 2
1
0
```

### 样例输出 #2

```
1
4
2
3
```

## 样例 #3

### 样例输入 #3

```
1 1
0
```

### 样例输出 #3

```
1
```

## 提示

对于样例1

(1,2,3) 递归深度为3层，字典序最小

对于样例2

(1, 4, 2, 3)递归深度为4层，字典序最小

(1,2,3,4) -> (1) 2 (3,4) -> 1 2 3 (4) 字典序小，但是只有3层深度

对于40%的数据，1 \leq N,$k\leq10$

对于70%的数据，$1 \leq N$,$k \leq 10000$

对于100%的数据，$1 \leq N$,$k \leq 50000$,$0 \leq a_i \leq 10^9$