# Problem B 隔岸观火

## 1.1 题目描述

实不相瞒，小Y其实是一名炎国的老天师，具有翻天覆地、移山造海的本事。一般来讲，像他这样的高人都隐居在奇山险峰之上。有一天他走出院子，发现对面的群山连绵不绝，波荡起伏，心中甚是高兴，但是仔细一看又感觉不对劲，因为并非所有的地方都是这样。他从左到右把每一座山峰的高度都记录了下来，第 $i$ 座山的高度为 $h_i$ 。在他眼里，一幅好的山景就应该如同波浪一样起起伏伏，也就是说对于每一座山峰，其高度应该同时（严格）大于与它相邻的两座山峰，或者同时（严格）小于与它相邻的两座山峰。为了使得眼前的山峰能够更加美观，小Y决定将其中的一些山峰移走，移走之后剩下的山峰会自动靠拢。当然小Y他也想尽可能的保留原来的景致，所以他想问问你，他最多能保留多少座山峰?

## 1.2 输入描述

输入包含两行。
第一行包含一个正整数$n$，其中$n\leq10^5$。
第二行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 座山峰的高度 $h$ ，$h_i\leq10^5$。
数据保证所有的 $h_i$ 随机生成，服从在某一个区间内的随机分布。

## 1.3 输出描述

输出一个数，表示最多能保留多少座山峰。

## 1.4 样例展示

### 样例 #1

#### 样例输入 #1

```
5
5 3 2 1 2
```

#### 样例输出 #1

```
3
```


## 1.5 题解

~~很显然~~这题是一道贪心题。

思考方向：本题数据范围在$10^5$内，所以考虑$O(n)$或者$O(nlogn)$的算法。仔细阅读题目，得知“好的山景”只和它两边的山的高度有关系，所以具有局部最优解可以推广到整体的性质，贪心成立。

由题意我们可以得知需要构造一个数列使得任意一个数大于或小于两边的数，所以我们可以寻找 $h$ 的转折点（即正好由递增变为递减或由递减变为递增的那个点），很显然对于任意一个转折点两侧的转折点均符合题目要求，所以只需要求转折点的数量即可，时间复杂度$O(n)$，可以通过。

## 1.6 标程

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e6 + 5;
int n, con, h[N], ans = 1;

int main() {
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> h[i];
    }
    if (h[2] >= h[1]) {
        con = 1;
    }
    for (int i = 1; i <= n; i++) {
        if (con == 0 && i == n) {
            ans++;
            break;
        }
        if (con ==1 && h[i + 1] < h[i]) {
            ans++;
            con = 0;
            continue;
        }
        if (con == 0 && h[i + 1]> h [i]) {
            ans++;
            con = 1;
            continue;
        }
    }
    cout << ans << endl;
    return 0;
}
```