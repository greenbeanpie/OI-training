# Problem C 炭烤沙虫腿

## 1.1 题目描述

夏日炎炎，小Y带着小X来到了汐斯塔市旅游，在海边他们决定尝一尝当地的美食
“炭烤沙虫腿”。这种美食其实跟烧烤骨肉相连串有异曲同工之妙，每一根“炭烤沙虫腿”串上都串着很多块食材，每一块食材都是某一种沙虫腿肉，也就是说，我们可以用一个只包含小写字母的字符串来表示这个“炭烤沙虫腿”串。现在小Y手中有一串炭烤沙虫腿，我们记为A，总共串了 $n$ 块食材，准备送给小X。但是小X是一个挑食的人，她想要吃一串更好看的串串，具体来讲，她规定了这个串串的长度 $m$ ，并且每一块食材的种类，我们记为 $B$ 。因为小Y手头只有这么一根串串，所以他想截取 $A$ 中的 $k$ 个子串拼在一起，按照原来的顺序串在一起串成B，他想知道有多少种方案?

## 1.2 输人描述

输人包含三行。
第一行包含三个正整数n，m，k，表示A， B串的长度以及截取出来子串的段数，其中
$n<1000$，$m<200$，$k \leq m$。

第二行包含一个长度为$n$的字符串$A$，只包含小写字母，表示小Y手中的炭烤沙虫
腿串。

第三行包含一个长度为$m$的字符串$B$，只包含小写字母，表示小X想吃的炭烤沙虫
腿串。

## 1.3 输出描述

输出一行，表示从A串中截取 $k$ 个子串拼成B串串的方案数对$10^9+7$取模
的值。

## 1.4 样例展示

### 样例 #1

#### 样例输入 #1

```
6 3 1
aabaab
aab
```

#### 样例输出 #1

```
2
```

## 1.5 题解

题意：有串A、B，截取A中的K个字串拼成B，输出方案数。

~~很显然~~这是动态规划问题。~~众所周知只要不是贪心不是搜索不是暴力枚举就是DP~~。关键在于DP数组状态的设计。此处我们记 $f_{i,j,p,v}$ 表示A串已经匹配到了i的位置，B串已经匹配到了j的位置，现在已经使用了P个字串，v表示a串中第i个位置是否选择，此处$v\in{0,1}$。状态数为 $n \times m \times k$ ，考虑如何转移。

首先分情况讨论。第一种情况是a串的第i个位置和b串的第j个位置是相同的，这意味着这个位置是正好可以匹配到的，所以我们考虑 $f_{v,j,p,0}$ 这个位置的状态是怎么获得的。如果第i位不选，那么它的状态和上一位的状态是一样的，那么我们只要将它的上一位选和不选的情况相加即可。如果第i位要选，也就是意味着第i位和第j位是匹配的，所以我们要将这个字串上一个位置处理到了j-1位的所有可能的情况都相加，这里需要分出两种情况，一种情况是继续使用旧字串，一种情况是重新开始一个新字串的匹配，这时候我们就要将这两种情况都加起来。

第二种情况是字符不匹配，那么显然此时v=1时的值一定是0，v=0时和上一个时间的匹配状态相同。

现在状态转移方程已经完成了，因为dp是斯维数组，M又较大，可能会爆栈或者RE，考虑优化。我们由状态转移方程得知当前状态只和上一个状态有关，那么我们只需要存两个状态即可。注意到数据范围可能会爆int，所以要在每次相加时都取模或考虑使用long long。

## 1.6 标程

```cpp
#include <bits/stdc++.h>

const int N = 1005;
const int M = 205;
const int MOD = 1e9 + 7;

int n, m, k, v = 1;
int f[2][M][M][2];
char a[N], b[M];

int add(int x, int y)
{
 return (x += y) >= MOD ? x -= MOD : x;
}

int main()
{
 scanf("%d%d%d", &n, &m, &k);
 scanf("%s%s", a + 1, b + 1);

 f[0][0][0][0] = f[1][0][0][0] = 1;
 for (int i = 1; i <= n; ++i, v ^= 1)
 {
  for (int j = 1; j <= m; ++j)
  {
   for (int p = 1; p <= k; ++p)
   {
    if (a[i] == b[j])
    {
     f[v][j][p][0] = add(f[v ^ 1][j][p][0], f[v ^ 1][j][p][1]);
     f[v][j][p][1] = add(f[v ^ 1][j - 1][p][1],
          add(f[v ^ 1][j - 1][p - 1][0], f[v ^ 1][j - 1][p - 1][1]));
    }
    else
    {
     f[v][j][p][0] = add(f[v ^ 1][j][p][0], f[v ^ 1][j][p][1]);
     f[v][j][p][1] = 0;
    }
   }
  }
 }

 printf("%d\n", add(f[n & 1][m][k][0] , f[n & 1][m][k][1]));
 return 0;
}
```
