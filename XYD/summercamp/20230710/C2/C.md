# Problem C 炭烤沙虫腿

## 1.1 题目描述

夏日炎炎，小Y带着小X来到了汐斯塔市旅游，在海边他们决定尝一尝当地的美食
“炭烤沙虫腿”。这种美食其实跟烧烤骨肉相连串有异曲同工之妙，每一根“炭烤沙虫腿”串上都串着很多块食材，每一块食材都是某一种沙虫腿肉，也就是说，我们可以用一个只包含小写字母的字符串来表示这个“炭烤沙虫腿”串。现在小Y手中有一串炭烤沙虫腿，我们记为A，总共串了 $n$ 块食材，准备送给小X。但是小X是一个挑食的人，她想要吃一串更好看的串串，具体来讲，她规定了这个串串的长度 $m$ ，并且每一块食材的种类，我们记为 $B$ 。因为小Y手头只有这么一根串串，所以他想截取 $A$ 中的 $k$ 个子串拼在一起，按照原来的顺序串在一起串成B，他想知道有多少种方案?

## 1.2 输人描述

输人包含三行。
第一行包含三个正整数n，m，k，表示A， B串的长度以及截取出来子串的段数，其中
$n<1000$，$m<200$，$k \leq m$。

第二行包含一个长度为$n$的字符串$A$，只包含小写字母，表示小Y手中的炭烤沙虫
腿串。

第三行包含一个长度为$m$的字符串$B$，只包含小写字母，表示小X想吃的炭烤沙虫
腿串。

## 1.3 输出描述

输出一行，表示从A串中截取k个子串拼成B串串的方案数对$100000007$取模
的值。

## 1.4 样例展示

### 样例 #1

#### 样例输入 #1

```
6 3 1
aabaab
aab
```

#### 样例输出 #1

```
2
```

## 1.5 题解



## 1.6 标程

```cpp
#include <bits/stdc++.h>

const int N = 1005;
const int M = 205;
const int MOD = 1e9 + 7;

int n, m, k, v = 1;
int f[2][M][M][2];
char a[N], b[M];

int add(int x, int y)
{
	return (x += y) >= MOD ? x -= MOD : x;
}

int main()
{
	scanf("%d%d%d", &n, &m, &k);
	scanf("%s%s", a + 1, b + 1);

	f[0][0][0][0] = f[1][0][0][0] = 1;
	for (int i = 1; i <= n; ++i, v ^= 1)
	{
		for (int j = 1; j <= m; ++j)
		{
			for (int p = 1; p <= k; ++p)
			{
				if (a[i] == b[j])
				{
					f[v][j][p][0] = add(f[v ^ 1][j][p][0], f[v ^ 1][j][p][1]);
					f[v][j][p][1] = add(f[v ^ 1][j - 1][p][1],
										add(f[v ^ 1][j - 1][p - 1][0], f[v ^ 1][j - 1][p - 1][1]));
				}
				else
				{
					f[v][j][p][0] = add(f[v ^ 1][j][p][0], f[v ^ 1][j][p][1]);
					f[v][j][p][1] = 0;
				}
			}
		}
	}

	printf("%d\n", add(f[n & 1][m][k][0] , f[n & 1][m][k][1]));
	return 0;
}
```
